import logging
from typing import Optional, Dict, Any, List
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

from ..identies import IdentiesClient
from ..identies.exceptions import (
    IdentiesError,
    IdentiesAuthenticationError,
    IdentiesValidationError,
    IdentiesClientError,
    IdentiesServerError,
)
from ..schemas.user import UserOnboard, UserNeedsOnboarding

logger = logging.getLogger(__name__)


class UserOnboardingMiddleware(BaseHTTPMiddleware):
    """
    Middleware for handling user onboarding independently of authentication.
    This middleware checks if request.user is set and handles onboarding if needed.
    """

    def __init__(
        self, app, identies_base_url: Optional[str] = None, user_service_factory=None
    ):
        super().__init__(app)
        self.identies_base_url = identies_base_url
        self.user_service_factory = user_service_factory

        # Initialize Identies client if base URL is provided
        self.identies_client: Optional[IdentiesClient]
        if self.identies_base_url:
            self.identies_client = IdentiesClient(
                base_url=self.identies_base_url,
                timeout=10,  # Shorter timeout for middleware
                max_retries=1,  # Fewer retries for middleware
            )
        else:
            self.identies_client = None

        logger.info(
            f"UserOnboardingMiddleware initialized with Identies base URL: {self.identies_base_url}"
        )

    async def dispatch(self, request: Request, call_next):
        """
        Process the request and handle user onboarding if needed.
        Only processes requests that have a user set in request.state.
        """

        # Check if user is already set in request state
        if not hasattr(request.state, "user") or request.state.user is None:
            # No user set, skip onboarding
            return await call_next(request)

        # User is set, check if they need onboarding
        user = request.state.user

        # Check if user needs onboarding (you can customize this logic based on your needs)
        if self._user_needs_onboarding(user):
            # Handle user onboarding
            onboarded_user = await self._handle_user_onboarding(request, user)
            if onboarded_user:
                # Update the user in request state with the onboarded user
                request.state.user = onboarded_user
            else:
                # Onboarding failed, we cannot proceed with a UserNeedsOnboarding object
                # as downstream code expects a user with an 'id' attribute
                logger.error(f"User onboarding failed for external_id: {user.external_id}, cannot proceed with incomplete user object")
                from starlette.responses import JSONResponse
                return JSONResponse(
                    status_code=500,
                    content={"detail": "User onboarding failed. Please contact support if this issue persists."}
                )

        return await call_next(request)

    def _user_needs_onboarding(self, user: Any) -> bool:
        """
        Determine if a user needs onboarding.
        This is a placeholder - customize based on your business logic.
        For example, check if user has certain fields missing or is marked as needing onboarding.
        """
        # Check if user is a UserNeedsOnboarding object
        if isinstance(user, UserNeedsOnboarding):
            return user.needs_onboarding
        
        # Example: Check if user has required fields for onboarding
        if hasattr(user, "needs_onboarding"):
            return user.needs_onboarding

        return False

    async def _handle_user_onboarding(
        self, request: Request, user: Any
    ) -> Optional[Any]:
        """
        Handle the actual user onboarding process.
        Fetches complete user data from Identies and creates the user locally.
        """
        try:
            # First, fetch complete user data from Identies
            userinfo_response = await self._fetch_user_from_identies(request)

            if not userinfo_response:
                logger.error("Failed to fetch user data from Identies for onboarding")
                return None

            # Always try to use the user service for onboarding
            # TODO: We need to get rid of the external_id parameter, and use only the identies id.
            # The problem is that the token is being generated by an external IDP service, so we don't know the internal id.
            return await self._onboard_with_user_service(
                request, userinfo_response, user.external_id
            )
        except Exception as e:
            logger.error(f"Failed to onboard user: {e}")
            return None

    async def _onboard_with_user_service(
        self, request: Request, userinfo_response, external_id: str
    ) -> Optional[Any]:
        """
        Onboard user using the provided user service with Identies data.
        """
        try:
            if not self.user_service_factory:
                logger.error("No user service factory provided")
                return None

            # Create user data for onboarding from Identies response
            user_data = self._create_user_onboard_from_identies_response(
                userinfo_response, external_id
            )

            # Create UserService instance using the factory
            user_service = self.user_service_factory(request)

            # Use the user service to onboard the user
            onboarded_user = user_service.onboard_user(user_data)
            return onboarded_user
        except Exception as e:
            logger.error(f"User service onboarding failed: {e}")
            return None

    async def _fetch_user_from_identies(self, request: Request) -> Optional[Any]:
        """
        Fetch complete user data from Identies using the authorization token.
        """
        try:
            if not self.identies_client:
                logger.warning("Identies client not configured for user onboarding")
                return None

            # Get the authorization token from the request
            auth_header = request.headers.get("Authorization")
            if not auth_header or not auth_header.startswith("Bearer "):
                logger.warning("No Bearer token found for user onboarding")
                return None

            token = auth_header[len("Bearer ") :]

            # Set the authorization token in the client for this request
            self.identies_client.session.headers.update(
                {"Authorization": f"Bearer {token}"}
            )

            try:
                # Fetch complete user info from Identies using the client
                userinfo_response = self.identies_client.userinfo()
                return userinfo_response

            finally:
                # Clean up: remove the Authorization header from client after use
                if "Authorization" in self.identies_client.session.headers:
                    del self.identies_client.session.headers["Authorization"]

        except IdentiesAuthenticationError:
            logger.warning("Identies authentication failed during user onboarding")
            return None
        except IdentiesValidationError as e:
            logger.warning(f"Identies validation error during user onboarding: {e}")
            return None
        except (IdentiesClientError, IdentiesServerError) as e:
            logger.error(f"Identies client error during user onboarding: {e}")
            return None
        except IdentiesError as e:
            logger.error(f"Unexpected Identies error during user onboarding: {e}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during Identies onboarding: {e}")
            return None

    async def _update_user_with_identies_data(
        self, user: Any, userinfo_response
    ) -> Any:
        """
        Update user object with Identies data as a fallback when no user service is available.
        """
        return self._update_user_with_identies_response(user, userinfo_response)

    def _update_user_with_identies_response(self, user: Any, userinfo_response) -> Any:
        """
        Update user object with additional information from Identies UserResponse.
        This is a fallback method when no user service is available.
        """
        # Update user attributes with userinfo response data
        if hasattr(user, "__dict__"):
            # Map UserResponse fields to user object
            field_mapping = {
                "id": "id",
                "email": "email",
                "first_name": "first_name",
                "last_name": "last_name",
                "avatar_url": "avatar_url",
                "avatar_asset_id": "avatar_asset_id",
                "username": "username",
                "provider": "provider",
                "verified": "verified",
                "theme_preference": "theme_preference",
            }

            for response_field, user_field in field_mapping.items():
                if hasattr(userinfo_response, response_field):
                    value = getattr(userinfo_response, response_field)
                    if hasattr(user, user_field):
                        setattr(user, user_field, value)

        return user

    def _create_user_onboard_from_identies_response(
        self, userinfo_response, external_id
    ) -> UserOnboard:
        """
        Create UserOnboard data from Identies UserResponse for local user creation.
        """
        return UserOnboard(
            external_id=external_id,
            id=userinfo_response.id,
            email=userinfo_response.email,
            first_name=userinfo_response.first_name,
            last_name=userinfo_response.last_name,
            avatar_url=userinfo_response.avatar_url,
        )

    def _extract_user_data_for_onboarding(self, user: Any) -> Dict[str, Any]:
        """
        Extract user data needed for onboarding from the user object.
        Customize this based on your UserOnboard schema requirements.
        """
        return {
            "external_id": getattr(user, "id", None),
            "id": getattr(user, "id", None),
            "email": getattr(user, "email", None),
            "first_name": getattr(user, "first_name", ""),
            "last_name": getattr(user, "last_name", ""),
            "avatar_url": getattr(user, "avatar_url", None),
        }

    def _update_user_with_info(self, user: Any, userinfo: Dict[str, Any]) -> Any:
        """
        Update user object with additional information from userinfo.
        This is a fallback method when no user service is available.
        """
        # Update user attributes with userinfo data
        if hasattr(user, "__dict__"):
            for key, value in userinfo.items():
                if hasattr(user, key):
                    setattr(user, key, value)

        return user
